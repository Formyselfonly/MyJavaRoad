## 微服务Microservices

一个项目,如果把所有的功能全部写在里面,那么后续发展起来,项目就很庞大,处理不了,难以更新和维护, 也不适合分工.    于是我们把所有功能都划分为一个一个的微服务,把他们分开.      然后应用的时候再联系在一起.

## 分布式Cloud

我们用微服务把功能拆分为一个一个的模块,然后再用Cloud也就是分布式 云服务把他们联合起来.

分布式有哪些困难呢? 很显然,各个服务运行在不同的机器上,那么就需要远程调用,包括各种配置都很麻烦.   而我们有一个SpringCloud,它就可以帮我们协调.  SpringBoot构建一切,SpringCLoud协调一切,SpringCloudDataFLow连接一切![image-20221005151340725](D:\Users\Pictures\Saved Pictures\image-20221005151340725.png)

## 为什么需要SpringBoot?

Spring是一个很庞大的生态,SpringFramework,SpringSession,SpringData,SpringCloud,SpringSecurity,还有什么Mybatis,那么多东西整合起来写配置很麻烦,于是SpringBoot站出来了,解决了Spring项目的启动问题,它帮助我们整合,我们不再需要那么麻烦的配置了.   SpringBoot的底层就是SpringFramework,它就是一个方便的Spring生态.  SpringBoot是整合Spring生态的一站式框架.

## Spring核心特性

**IOC**与**AOP**

我们放到一起说,方便后续我们自己理解,概念要联系到一起或者结合实际场景才能体现它真正的含义

IOC，英文全称Inversion of Control，意为控制反转。AOP，英文全称Aspect-Oriented Programming，意为面向切面编程。

Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IOC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。

IOC控制反转，简单点说，就是创建对象的控制权，被反转到了Spring框架上。 通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工作交给了IOC容器。        也就是说,我们自己不new对象,而是让Spring容器帮助我们new对象.  

这个Spring容器,或者说Spring IOC容器,它具有依赖注入功能，可以创建对象的容器。IoC容器负责实例化和配置应用程序中的对象并建立这些对象之间的依赖。

那我们是怎么实现IOC的呢?     **依赖注入**

依赖注入：由IoC容器动态地将某个对象所需要的外部资源（包括对象、资源、常量数据）注入到组件(Controller, Service等）之中。简单点说，就是IoC容器会把当前对象所需要的外部资源动态的注入给我们。

Spring依赖注入的方式主要有四个

基于**注解注入**方式(也就是直接@)   set注入方式、构造器注入方式、静态工厂注入方式。推荐使用基于注解注入方式，配置较少，比较方便。

AOP面向切面编程,是一种纵向的编程.   比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。

在实际开发中，比如商品查询、促销查询等业务，都需要记录日志、异常处理等操作，AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。

AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等。

AOP相关名词

切面(Aspect):**共有功能的实现为切面**,比如日志切面,权限切面.  **在实际开发中切面是一个类**。当Java类使用了@Aspect注解修饰时，就能被AOP容器识别为切面。

通知（Advice）：切面的具体实现。**就是要给目标对象织入的事情**。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。**在实际开发中通知是切面类中的一个方法**，具体属于哪类通知，通过方法上的注解区分。

连接点（JoinPoint）：程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出等。Spring只支持方法级的连接点。一个类的所有方法前、后、抛出异常时等都是连接点。



切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。



比如，在上面所说的连接点的基础上，来定义切入点。我们有一个类，类里有10个方法，那就产生了几十个连接点。但是我们并不想在所有方法上都织入通知，我们只想让其中的几个方法，在调用之前检验下入参是否合法，那么就用切点来定义这几个方法，让切点来筛选连接点，选中我们想要的方法。切入点就是来定义哪些类里面的哪些方法会得到通知。



目标对象（Target）：那些即将切入切面的对象，也就是那些被通知的对象。这些对象专注业务本身的逻辑，所有的共有功能等待AOP容器的切入。

